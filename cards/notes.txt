---- BASICS ----

// Package Basics
package main: means our file is to be executable
        files with package main must have a main function:
            func main() {
                ...
            }

// Ways of Variable Initialization
variable initialization: var a string = "Hello, world!"
variable initialization: a := "Hello, world"
    It is important to understand that variables cannot be assigned to outside of a function
    but they can be created outside of functions

// Variable Reassignment
a = "Welcome to the world!"

// Function Declarations
func exampleFunction(var a name) string {
    return ("Hello, " + name)
}

// Data Structures
Array: Fixed length list of things
Slice: An array that can grow or shrink
    All items/elements inside of a slice has to be of the same type:
        []<data_type> {<value>,<value>,...}
        cards := []string {"Ace of Clubs", "Five of Diamonds", "Three of Spades"}

        // Appending to a Slice
        cards = append(cards, "Five of Clubs")
            It is important to note that the append function does not modify the existing cards string slice
            instead it returns a new string slice containing the old and added values.
            that is why we said cards = append and didnt just type: append(cards, "Five of clubs")

        // Iterating over a slice: see for loops notes

// For Loops
for <index>, <current_value> := range <item_to_loop_through>
for i, card := range cards {
    fmt.Println(i, card)
  }
  now this looks odd... but trust me it is very simple, we use i as the "index" of each card inside of the cards slice
  so this will print out each card inside of the string slice and it will prepend the index of each card so the output
  would look something like:
  [gagem@Anubis cards]$ go run main.go
    0 Ace of Diamonds
    1 Five of Diamonds
    2 Six of Spades
    explanation:
        index = the current index of the value in the provided array or slice
        current_value = the value/item/element currently inside of the loop from the array or slice
        item_to_loop_through = the slice or array to loop through


---- OOP IN GO? ----

// GO DOES NOT TAKE ON A CLASSIC OOP APPROACH!
// In the golang ecosystem, we create our own data types, and we can create whats known as a recieve function.
// A recieve function is like a "method"
// A method is like a function that belongs to an instance of a class or object 
// such as seen in a classic OOP approach like javas approach


// Declaring our own types
type <name> <data type>
example:
type deck []string          // we now have a new data type called deck
                            this data type inherits all of the functionality and methods
                            of the string slice '[]string' data type
                            and we can replace []string with deck in any places that we have used it! pretty cool right?
                            can you believe its that simple lol?
                            Oh, you dont believe me?
                            well... lets import the reflect library and double check...
                            =====================

                            ====== main.go ======
                            package main

                            import (
                                "fmt"
                                "reflect"
                            )

                            func main() {
                            cards := deck {"Ace of Diamonds", newCard()}
                            cards = append(cards, "Six of Spades")

                            for i, card := range cards {
                                fmt.Println(i, card)
                            }

                            fmt.Println(reflect.TypeOf(cards))
                            }

                            func newCard() string {
                            return "Five of Diamonds"
                            }
                            =====================

                            ====== deck.go ======
                            package main

                            // Create a new type of 'deck'
                            // which is a slice of strings / string slice

                            type deck []string
                            =====================

                            ====== test.sh ======
                            go run main.go deck.go
                            =====================

                            ====== OUTPUT ======
                            [gagem@Anubis cards]$ ./test.sh
                            0 Ace of Diamonds
                            1 Five of Diamonds
                            2 Six of Spades
                            main.deck
                            =====================
                            Believe me now?

                            Okay, now what was the point of creating our own data type?
                            well, we can now use what is known as a reciever function, 
                            which will automatically be made available to ANY variable with the type of 'deck'.



// Reciever functions
func (<variable> <datatype>) <function name>(<parameters>) {}
func (d deck) print() {}
    Okay but what does this mean? well it means every variable of type deck inside of our project 
    now gets access to this print method

    explanation of syntax:
        func (<variable> <datatype>) <function name>(<parameters>) {}

        variable = the actual copy of the variable we are working with is
                              available in the function as a variable called '<variable>'
                              lets say our data type was called a strmatrix we would create our recieve function like:
                              func (s strmatrix) exampleFuncName() {}
                              // we could give variable any name but we usually just use the first letter of the
                                datatype we are working with. golang likes short simple variable names, get over it.

        <datatype> = our custom data type, this just specifies what datatype has access to our reciever function

    // How to call this reciever function?:
        strmatrix.exampleFuncName()         // very difficult right? lmao

    // can we use reciever functions for primitive data types? no... and for good reason, it would lead to mass amounts
        of un needed reciever functions being used in almost every application.

        // okay now here is an example of our current reciever function:
            func (d deck) print() {
	            for i, card := range d {
		            fmt.Println("Index:", i, "|| Card:", card)
                }
            }
        


===============================================================
---- ENDING NOTE FOR NERDS LIKE ME THAT WANT TO KNOW IT ALL ---
===============================================================

How go build Works:

    Package Dependency Resolution:
        When you run go build in a directory containing Go files, GoLang first resolves dependencies based on import statements. Each Go file typically belongs to a package defined by its package declaration at the top of the file.

    Building Executables:
        If you have a Go file with package main (typically the file containing func main()), go build will compile that file and link it with any necessary packages specified in your import statements.

    Output:
        The output of go build is usually a single executable file (or binary) if your project consists of a single main package. This executable file contains all the necessary code from your main package and its dependencies.

    Multiple Files with package main:
        If your project consists of multiple Go files with package main, go build will compile all of them into separate object files and then link them together into a single executable. Each Go file with package main will contribute to the final executable.

Example:

Let's say you have a project with the following structure:

go

myproject/
├── main.go    // package main
├── utils.go   // package main
└── sub/
    └── sub.go // package main

    Running go build in the myproject directory will compile main.go, utils.go, and sub/sub.go (if they have package main), and link them into a single executable binary.

Additional Notes:

    Makefiles and Go: While GoLang does not use Makefile for building by default, you can still use Makefiles if you prefer to automate certain tasks or build steps beyond what go build provides. Makefiles can help with tasks like cleaning up binaries, running tests, or handling complex build configurations.

    Cross-Platform Builds: GoLang's go build can also cross-compile executables for different platforms by specifying the GOOS and GOARCH environment variables. For example, GOOS=windows GOARCH=amd64 go build will compile for Windows on an AMD64 architecture.

In summary, go build is designed to compile and link all necessary Go files into a single executable when dealing with package main. It simplifies the build process by handling dependencies and creating a standalone executable file ready for execution.